import { spawn } from "child_process";
import { existsSync } from "fs";
import { mkdir, mkdtemp, readFile, rm, writeFile } from "fs/promises";
import { tmpdir } from "os";
import { join, resolve } from "path";

const CLI_PATH = resolve(process.cwd(), "dist/cli.js");

export class TestRepo {
  constructor(path, packageManager = "pnpm") {
    this.path = path;
    this.packageManager = packageManager;
  }

  async init() {
    // Initialize git repo
    await this.runCommand("git", ["init"]);
    await this.runCommand("git", ["config", "user.email", "test@example.com"]);
    await this.runCommand("git", ["config", "user.name", "Test User"]);

    // Create package.json
    const packageJson = {
      name: "test-project",
      version: "1.0.0",
      dependencies: {
        lodash: "^4.17.21",
      },
    };
    await writeFile(
      join(this.path, "package.json"),
      JSON.stringify(packageJson, null, 2)
    );

    // Create appropriate lockfile
    await this.createLockfile();

    // Create .gitignore
    await writeFile(join(this.path, ".gitignore"), "node_modules/\n");

    // Initial commit
    await this.runCommand("git", ["add", "."]);
    await this.runCommand("git", ["commit", "-m", "Initial commit"]);

    return this;
  }

  async createLockfile(modified = false) {
    const lockfiles = {
      pnpm: {
        filename: "pnpm-lock.yaml",
        content: `lockfileVersion: '9.0'

settings:
  autoInstallPeers: true
  excludeLinksFromLockfile: false

importers:
  .:
    dependencies:
      lodash:
        specifier: ^4.17.21
        version: 4.17.21${modified ? "\n      # Modified for testing" : ""}

packages:
  lodash@4.17.21:
    resolution: {integrity: sha512-v2kDEe57lecTulaDIuNTPy3Ry4gLGJ6Z1O3vE1krgXZNrsQ+LFTGHVxVjcXPs17LhbZVGedAJv8XZ1tvj5FvSg==}

snapshots:
  lodash@4.17.21: {}
`,
      },
      yarn: {
        filename: "yarn.lock",
        content: `# THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
# yarn lockfile v1

lodash@^4.17.21:
  version "4.17.21"
  resolved "https://registry.yarnpkg.com/lodash/-/lodash-4.17.21.tgz#679591c564c3bffaae8454cf0b3df370c3d6911c"
  integrity sha512-v2kDEe57lecTulaDIuNTPy3Ry4gLGJ6Z1O3vE1krgXZNrsQ+LFTGHVxVjcXPs17LhbZVGedAJv8XZ1tvj5FvSg==${
    modified ? "\n# Modified for testing" : ""
  }
`,
      },
      npm: {
        filename: "package-lock.json",
        content:
          JSON.stringify(
            {
              name: "test-project",
              version: "1.0.0",
              lockfileVersion: 3,
              requires: true,
              packages: {
                "": {
                  name: "test-project",
                  version: "1.0.0",
                  dependencies: {
                    lodash: "^4.17.21",
                  },
                },
                "node_modules/lodash": {
                  version: "4.17.21",
                  resolved:
                    "https://registry.npmjs.org/lodash/-/lodash-4.17.21.tgz",
                  integrity:
                    "sha512-v2kDEe57lecTulaDIuNTPy3Ry4gLGJ6Z1O3vE1krgXZNrsQ+LFTGHVxVjcXPs17LhbZVGedAJv8XZ1tvj5FvSg==",
                },
              },
            },
            null,
            2
          ) + (modified ? "\n/* Modified for testing */" : ""),
      },
    };

    const lockfile = lockfiles[this.packageManager];
    await writeFile(join(this.path, lockfile.filename), lockfile.content);
  }

  async modifyLockfile() {
    await this.createLockfile(true);
  }

  async addConfig(config) {
    const packageJsonPath = join(this.path, "package.json");
    const packageJson = JSON.parse(await readFile(packageJsonPath, "utf8"));
    packageJson.lockfileGuardian = config;
    await writeFile(packageJsonPath, JSON.stringify(packageJson, null, 2));
  }

  async runCommand(command, args, options = {}) {
    return new Promise((resolve, reject) => {
      const proc = spawn(command, args, {
        cwd: this.path,
        stdio: "pipe",
        ...options,
      });

      let stdout = "";
      let stderr = "";

      proc.stdout?.on("data", (data) => {
        stdout += data.toString();
      });

      proc.stderr?.on("data", (data) => {
        stderr += data.toString();
      });

      proc.on("close", (code) => {
        resolve({
          exitCode: code,
          stdout: stdout.trim(),
          stderr: stderr.trim(),
        });
      });

      proc.on("error", reject);
    });
  }

  async hasHook(hookName) {
    const hookPath = join(this.path, ".git", "hooks", hookName);
    try {
      const content = await readFile(hookPath, "utf8");
      return content.includes("lockfile-guardian check --hook");
    } catch {
      return false;
    }
  }

  async hasGuardianData() {
    return existsSync(join(this.path, ".git", "lockfile-guardian"));
  }

  async getGuardianData() {
    try {
      return await readFile(
        join(this.path, ".git", "lockfile-guardian"),
        "utf8"
      );
    } catch {
      return null;
    }
  }

  async fileExists(relativePath) {
    return existsSync(join(this.path, relativePath));
  }

  async readFile(relativePath) {
    return readFile(join(this.path, relativePath), "utf8");
  }

  async writeFile(relativePath, content) {
    await writeFile(join(this.path, relativePath), content);
  }

  async commitChanges(message = "Test commit") {
    await this.runCommand("git", ["add", "."]);
    await this.runCommand("git", ["commit", "-m", message]);
  }

  async setupHusky() {
    // Create .husky directory
    await mkdir(join(this.path, ".husky"), { recursive: true });

    // Set git hooks path to .husky
    await this.runCommand("git", ["config", "core.hooksPath", ".husky"]);

    // Create a sample pre-commit hook with lint-staged content
    const preCommitContent = `#!/usr/bin/env sh
. "$(dirname -- "$0")/_/husky.sh"

npx lint-staged
`;
    await writeFile(join(this.path, ".husky", "pre-commit"), preCommitContent);
    await this.runCommand("chmod", ["+x", ".husky/pre-commit"]);

    // Add lint-staged config to package.json
    const packageJsonPath = join(this.path, "package.json");
    const packageJson = JSON.parse(await readFile(packageJsonPath, "utf8"));
    packageJson["lint-staged"] = {
      "*.{js,ts,tsx}": ["prettier --write", "eslint --fix"],
      "*.{json,md}": ["prettier --write"],
    };
    packageJson.devDependencies = {
      ...packageJson.devDependencies,
      husky: "^9.0.0",
      "lint-staged": "^15.0.0",
      prettier: "^3.0.0",
    };
    await writeFile(packageJsonPath, JSON.stringify(packageJson, null, 2));
  }

  async hasHuskyHook(hookName) {
    const hookPath = join(this.path, ".husky", hookName);
    try {
      const content = await readFile(hookPath, "utf8");
      return content.includes("lockfile-guardian check --hook");
    } catch {
      return false;
    }
  }

  async readHuskyHook(hookName) {
    try {
      return await readFile(join(this.path, ".husky", hookName), "utf8");
    } catch {
      return null;
    }
  }

  async isHuskyProject() {
    try {
      const hooksPath = await this.runCommand("git", [
        "config",
        "--get",
        "core.hooksPath",
      ]);
      return (
        hooksPath.stdout.trim() === ".husky" &&
        existsSync(join(this.path, ".husky"))
      );
    } catch {
      return false;
    }
  }

  async createBranch(branchName) {
    await this.runCommand("git", ["checkout", "-b", branchName]);
  }

  async switchBranch(branchName) {
    await this.runCommand("git", ["checkout", branchName]);
  }
}

export async function createTestRepo(packageManager = "pnpm") {
  const tempDir = await mkdtemp(join(tmpdir(), "lockfile-guardian-test-"));
  const repo = new TestRepo(tempDir, packageManager);
  await repo.init();
  return repo;
}

export async function runCli(command, options = {}) {
  const { cwd = process.cwd(), ...spawnOptions } = options;

  return new Promise((resolve, reject) => {
    const args = command ? command.split(" ") : [];
    const proc = spawn("node", [CLI_PATH, ...args], {
      cwd,
      stdio: "pipe",
      ...spawnOptions,
    });

    let stdout = "";
    let stderr = "";

    proc.stdout?.on("data", (data) => {
      stdout += data.toString();
    });

    proc.stderr?.on("data", (data) => {
      stderr += data.toString();
    });

    proc.on("close", (code) => {
      resolve({
        exitCode: code,
        stdout: stdout.trim(),
        stderr: stderr.trim(),
      });
    });

    proc.on("error", reject);
  });
}

export async function cleanup(repo) {
  if (repo && repo.path) {
    await rm(repo.path, { recursive: true, force: true });
  }
}
